// Clients API Route
// Path: /api/clients

import { NextRequest, NextResponse } from 'next/server';
import {
    getClients,
    createClient,
    updateClient,
    createSubscription,
    getClientWithSubscriptions,
    supabaseAdmin,
} from '@/lib/db/supabase';
import type { CreateClientInput, ClientStatus, ClientType } from '@/lib/db/types';

// GET /api/clients - List all clients
export async function GET(request: NextRequest) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const status = searchParams.get('status') as ClientStatus | null;
        const type = searchParams.get('type') as ClientType | null;

        const clients = await getClients(status || undefined, type || undefined);

        // Enrich with subscription totals
        const enrichedClients = await Promise.all(
            clients.map(async (client) => {
                const full = await getClientWithSubscriptions(client.id);
                return {
                    ...client,
                    total_monthly: full?.total_monthly || 0,
                    has_mandate: !!full?.mandate,
                };
            })
        );

        return NextResponse.json({ clients: enrichedClients });
    } catch (error) {
        console.error('Error fetching clients:', error);
        return NextResponse.json(
            { error: 'Failed to fetch clients' },
            { status: 500 }
        );
    }
}

// POST /api/clients - Create a new client
export async function POST(request: NextRequest) {
    try {
        const body = await request.json();

        // Validate required fields
        const requiredFields = ['company_name', 'contact_name', 'email'];
        for (const field of requiredFields) {
            if (!body[field]) {
                return NextResponse.json(
                    { error: `Missing required field: ${field}` },
                    { status: 400 }
                );
            }
        }

        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(body.email)) {
            return NextResponse.json(
                { error: 'Invalid email format' },
                { status: 400 }
            );
        }

        // Check VAT number uniqueness (if provided)
        if (body.vat_number && body.vat_number.trim() !== '') {
            const { data: existingClient } = await supabaseAdmin.selectOne<{ id: string }>(
                'clients',
                `vat_number=eq.${body.vat_number.trim()}`
            );
            if (existingClient) {
                return NextResponse.json(
                    { error: 'Un client avec ce numéro de TVA existe déjà' },
                    { status: 409 }
                );
            }
        }

        const clientInput: CreateClientInput = {
            company_name: body.company_name,
            contact_name: body.contact_name,
            email: body.email,
            phone: body.phone || null,
            address: body.address || null,
            city: body.city || null,
            postal_code: body.postal_code || null,
            country: body.country || 'Luxembourg',
            vat_number: body.vat_number || null,
            status: body.status || 'active',
            client_type: body.client_type || 'new',
            cancellation_requested_at: null,
            cancellation_effective_at: null,
            cancellation_reason: null,
            cancellation_signed_at: null,
            sepa_exception: body.sepa_exception || false,
            sepa_exception_reason: body.sepa_exception_reason || null,
            notes: body.notes || null,
            commission_config: body.commission_config || null,
            payment_method: body.payment_method || 'sepa',
            zoho_contact_id: null,
            referral_code: null, // Will be generated by default in DB, or we can explictly set if passed? Ideally let DB default handling it or random gen here? 
            // The DB default handles generation for new clients. We only care about linking to referrer.
            referred_by: body.referred_by || null,
        };

        // Handle Referral Code Lookup
        if (body.referral_code && !clientInput.referred_by) {
            console.log(`Looking up referrer for code: ${body.referral_code}`);
            // We need to query supabaseAdmin to find the client with this code
            const { data: referrer, error: refError } = await supabaseAdmin
                .selectOne<{ id: string }>('clients', `referral_code=eq.${body.referral_code}`);

            if (referrer) {
                console.log(`Found referrer: ${referrer.id}`);
                clientInput.referred_by = referrer.id;
            } else {
                console.warn('Invalid referral code provided');
                // We could return error or just ignore. Choosing to ignore but log.
            }
        }

        // If the user provided a custom code for THIS new client? 
        // No, typically we let the system generate it, OR if migrating data we might set it.
        if (body.custom_referral_code) {
            clientInput.referral_code = body.custom_referral_code;
        }

        const client = await createClient(clientInput);

        // Sync to Zoho Books
        try {
            // Import dynamically to avoid circular dependencies if any, or just import at top
            const { zoho } = await import('@/lib/invoicing/zoho');

            console.log(`Syncing client ${client.email} to Zoho...`);
            const zohoContact = await zoho.getOrCreateContact({
                email: client.email,
                company_name: client.company_name,
                contact_name: client.contact_name,
                phone: client.phone || undefined,
                address: client.address || undefined,
                city: client.city || undefined,
                postal_code: client.postal_code || undefined,
                country: client.country || 'Luxembourg',
                vat_number: client.vat_number || undefined,
            });
            console.log(`Synced to Zoho Contact ID: ${zohoContact.contact_id}`);

            // Update client with zoho_contact_id
            await updateClient(client.id, { zoho_contact_id: zohoContact.contact_id });

        } catch (zohoError) {
            console.error('Failed to sync client to Zoho:', zohoError);
            // We don't block the response, just log the error
        }

        // Handle Initial Services
        if (body.initial_services && Array.isArray(body.initial_services)) {
            console.log('Processing initial services:', body.initial_services);
            const today = new Date();
            let startDate = new Date();

            // Toggle Logic: Full Month (1st) vs Half Month (15th)
            if (body.start_mode === 'half') {
                startDate = new Date(today.getFullYear(), today.getMonth(), 15);
            } else if (body.start_mode === 'full') {
                startDate = new Date(today.getFullYear(), today.getMonth(), 1);
            }

            const startDateStr = startDate.toISOString().split('T')[0];

            for (const service of body.initial_services) {
                if (service.selected && service.amount) {
                    try {
                        console.log(`Creating subscription for ${service.type} at ${service.amount}€`);
                        await createSubscription({
                            client_id: client.id,
                            service_type: service.type,
                            service_name: service.name || '',
                            monthly_amount: parseFloat(service.amount),
                            commission_percent: 0,
                            status: 'active',
                            started_at: startDateStr,
                            description: null,
                            cancelled_at: null,
                        });
                    } catch (subError) {
                        console.error('Failed to create initial subscription:', subError);
                    }
                }
            }
        }

        return NextResponse.json({ client }, { status: 201 });
    } catch (error) {
        console.error('Error creating client:', error);

        // Check for duplicate email
        if (error instanceof Error && error.message.includes('duplicate')) {
            return NextResponse.json(
                { error: 'A client with this email already exists' },
                { status: 409 }
            );
        }

        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Failed to create client' },
            { status: 500 }
        );
    }
}
